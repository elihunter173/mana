use std::str::FromStr;

// use bumpalo::{Bump, boxed::Box as BumpBox, collections::Vec as BumpVec};
use bumpalo::{boxed::Box as BumpBox, Bump};

use crate::{ast::{BinOp, Expr, Stmt}, types::Value};

grammar<'bump>(bump: &'bump Bump);

pub Stmts = Stmt*;

pub Stmt: Stmt<'bump> = {
    "print" "(" <Expr> ")" => Stmt::Print(<>),
};

Comma<T>: BumpVec<'bump, T> = {
    <v:(<T> ",")*> <e:T?> => {
        let mut v = BumpVec::from_iter_in(v, bump);
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

pub Expr: Expr<'bump> = {
    "typeof" "(" <Expr> ")" => Expr::Typeof(BumpBox::new_in(<>, bump)),
    Expr0,
};

ExprTier<Op, NextTier>: Expr<'bump> = {
    <l:ExprTier<Op, NextTier>> <op:Op> <r:NextTier> => {
        Expr::Binary(op, BumpBox::new_in(l, bump), BumpBox::new_in(r, bump))
    },
    NextTier,
};
Expr0 = ExprTier<Op0, Expr1>;
Op0: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Neq,
};
Expr1 = ExprTier<Op1, Expr2>;
Op1: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};
Expr2 = ExprTier<Op2, Atom>;
Op2: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

Atom: Expr<'bump> = {
    Literal => Expr::Literal(<>),
    "(" <Expr> ")",
};

Literal: Value = {
    r"[0-9]+(\.[0-9]+)?" => Value::Number(f64::from_str(<>).unwrap()),
    "true" => Value::Bool(true),
    "false" => Value::Bool(false),
}
