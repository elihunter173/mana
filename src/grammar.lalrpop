use std::str::FromStr;

use bumpalo::{boxed::Box as BumpBox, collections::Vec as BumpVec, Bump};
use num::{BigInt, Num};

use crate::ast::{UnaryOp, BinOp, Block, Expr, Ident, TypePath, Literal};

// XXX: I have things I test marked as pub(crate)

grammar(bump: &'input Bump);

Delimited<T, Delimiter>: BumpVec<'input, T> = {
    <v:(<T> Delimiter)*> <e:T?> => {
        let mut v = BumpVec::from_iter_in(v, bump);
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

Comma<T> = Delimited<T, ",">;

pub Program = Stmt*;

pub Stmt = <Expr> ";";

pub Expr: Expr<'input> = {
    ExprP0,
    Block => Expr::Block(<>),
    If,
    FunctionCall,
    Let,
    Set,
};

Block: Block<'input> = {
    "{" <stmts:Stmt*> "}" => {
        let stmts = stmts.into_iter().map(|x| BumpBox::new_in(x, bump));
        BumpVec::from_iter_in(stmts, bump)
    },
};

If: Expr<'input> = {
    "if" <cond:Expr> <true_block:Block> => {
        Expr::If {
            cond: BumpBox::new_in(cond, bump),
            true_expr: BumpBox::new_in(Expr::Block(true_block), bump),
            false_expr: None,
        }
    },
    "if" <cond:Expr> <true_block:Block> "else" <elif:If> => {
        Expr::If {
            cond: BumpBox::new_in(cond, bump),
            true_expr: BumpBox::new_in(Expr::Block(true_block), bump),
            false_expr: Some(BumpBox::new_in(elif, bump)),
        }
    },
    "if" <cond:Expr> <true_block:Block> "else" <false_block:Block> => {
        Expr::If {
            cond: BumpBox::new_in(cond, bump),
            true_expr: BumpBox::new_in(Expr::Block(true_block), bump),
            false_expr: Some(BumpBox::new_in(Expr::Block(false_block), bump)),
        }
    },
};

FunctionCall: Expr<'input> = {
    <Ident> "(" <Comma<Expr>> ")" => Expr::FnCall(<>),
};

Let: Expr<'input> = {
    "let" <id:Ident> <typ:(":" <TypePath>)?> "=" <e:Expr> => {
        Expr::Let(id, BumpBox::new_in(e, bump))
    },
};

Set: Expr<'input> = {
    <id:Ident> "=" <e:Expr> => Expr::Set(id, BumpBox::new_in(e, bump)),
};

ExprTier<Op, NextTier>: Expr<'input> = {
    <l:ExprTier<Op, NextTier>> <op:Op> <r:NextTier> => {
        Expr::Binary(op, BumpBox::new_in(l, bump), BumpBox::new_in(r, bump))
    },
    NextTier,
};

// TODO: Work in "and" and "or" but make it an error for them to be used at the
// same precedance
ExprP0 = ExprTier<OpP0, ExprP1>;
OpP0: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Neq,
};

ExprP1: Expr<'input> = {
    <l:ExprP1> <op:OpP1> <r:ExprP2> => {
        Expr::Binary(op, BumpBox::new_in(l, bump), BumpBox::new_in(r, bump))
    },
    // Don't let logical operators be on the same level
    <l:ExprP2> <op:LogicalOp> <r:ExprP2> => {
        Expr::Binary(op, BumpBox::new_in(l, bump), BumpBox::new_in(r, bump))
    },
    ExprP2,
};
LogicalOp: BinOp = {
    "and" => BinOp::Land,
    "or" => BinOp::Lor,
};
OpP1: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

ExprP2 = ExprTier<OpP2, UnaryExpr>;
OpP2: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

UnaryExpr = {
    "-" <a:Atom> => Expr::Unary(UnaryOp::Neg, BumpBox::new_in(a, bump)),
    Atom,
}

Atom: Expr<'input> = {
    Literal,
    Ident => Expr::Ident(<>),
    "(" <Expr> ")",
};

Ident: Ident<'input> = {
    r"[a-zA-Z_][0-9a-zA-Z_]*" => Ident { name: <> },
};

TypePath: TypePath<'input> = {
    <parents:(<Ident> ".")*> <typ:Ident> => {
        let mut v = BumpVec::from_iter_in(parents.into_iter(), bump);
        v.push(typ);
        TypePath { paths: v }
    },
};

pub(crate) Literal: Expr<'input> = {
    Float => Expr::Literal(<>),
    Int => Expr::Literal(<>),
    Bool => Expr::Literal(<>),
    String => Expr::Literal(<>),
};

// TODO: Support underscores
Int: Literal = {
    r"[0-9]+" => Literal::Int(BigInt::from_str_radix(<>, 10).unwrap()),
    r"0x[0-9a-fA-F]+" => {
        let digits = &<>[2..];
        Literal::Int(BigInt::from_str_radix(digits, 16).unwrap())
    },
    r"0o[0-7]+" => {
        let digits = &<>[2..];
        Literal::Int(BigInt::from_str_radix(digits, 8).unwrap())
    },
    r"0b[01]+" => {
        let digits = &<>[2..];
        Literal::Int(BigInt::from_str_radix(digits, 2).unwrap())
    },
}

Float: Literal = {
    r"[0-9]+\.[0-9]+" => Literal::Float(f64::from_str(<>).unwrap()),
};

Bool: Literal = {
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};

String: Literal = {
    <x:r#""([^\\"]|\\")*""#> => {
        let s = &x[1..(x.len() - 1)];
        // Unescape quotes
        let s = s.replace("\\\"", "\"");
        Literal::String(s)
    }
};
