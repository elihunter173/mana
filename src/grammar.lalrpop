use crate::ast::{UnaryOp, BinOp, Expr, Item, Ident, TypePath, Literal};
use crate::lexer::{LexError, Loc, Tok};

// XXX: I have things I test marked as pub(crate)

grammar<'input>(input: &'input str);

extern {
    type Location = Loc;
    type Error = LexError;

    enum Tok<'input> {
        "," => Tok::Comma,
        ":" => Tok::Colon,
        ";" => Tok::Semicolon,
        "->" => Tok::SingleArrow,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LCurly,
        "}" => Tok::RCurly,
        "[" => Tok::LSquare,
        "]" => Tok::RSquare,

        "=" => Tok::Equals,
        "." => Tok::Dot,
        ".." => Tok::DotDot,
        "..=" => Tok::DotDotEq,
        "+" => Tok::Plus,
        "+=" => Tok::PlusEq,
        "-" => Tok::Minus,
        "-=" => Tok::MinusEq,
        "*" => Tok::Star,
        "*=" => Tok::StarEq,
        "/" => Tok::Slash,
        "/=" => Tok::SlashEq,

        "fn" => Tok::Fn,
        "struct" => Tok::Struct,
        "enum" => Tok::Enum,
        "trait" => Tok::Trait,
        "type" => Tok::Type,
        "impl" => Tok::Impl,
        "import" => Tok::Import,
        "pub" => Tok::Pub,
        "let" => Tok::Let,
        "if" => Tok::If,
        "else" => Tok::Else,
        "for" => Tok::For,
        "while" => Tok::While,
        "loop" => Tok::Loop,
        "and" => Tok::And,
        "or" => Tok::Or,
        "not" => Tok::Not,

        "==" => Tok::DoubleEquals,
        "!=" => Tok::BangEquals,
        ">" => Tok::Gt,
        ">=" => Tok::Geq,
        "<" => Tok::Lt,
        "<=" => Tok::Leq,

        "true" => Tok::True,
        "false" => Tok::False,
        "Ident" => Tok::Ident(<&'input str>),
        "String" => Tok::String(<&'input str>),
        "Int" => Tok::Int(<&'input str>),
        "IntHex" => Tok::IntHex(<&'input str>),
        "IntOct" => Tok::IntOct(<&'input str>),
        "IntBin" => Tok::IntBin(<&'input str>),
        "Float" => Tok::Float(<&'input str>),
    }
}


Delimited<T, Delimiter>: Vec<T> = {
    <mut v:(<T> Delimiter)*> <e:T?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

Comma<T> = Delimited<T, ",">;

pub Program = Delimited<Item, ";">;

pub(crate) Item: Item = {
    FnDef,
}

FnDef: Item = {
    "fn" <name:Ident> "(" <args: Comma<(<Ident> ":" <TypePath>)>> ")" <return_type:("->" <TypePath>)?> <body:Block> => {
        Item::FnDef {
            name,
            args,
            return_type,
            body,
        }
    }
}

pub(crate) Expr: Expr = {
    ExprP0,
    Block => Expr::Block(<>),
    If,
    FunctionCall,
    Let,
    Set,
};

Block: Vec<Expr> = {
    "{" <Delimited<Expr, ";">> "}" => <>,
};

If: Expr = {
    "if" <cond:Expr> <true_block:Block> => {
        Expr::If {
            cond: Box::new(cond),
            true_expr: Box::new(Expr::Block(true_block)),
            false_expr: None,
        }
    },
    "if" <cond:Expr> <true_block:Block> "else" <elif:If> => {
        Expr::If {
            cond: Box::new(cond),
            true_expr: Box::new(Expr::Block(true_block)),
            false_expr: Some(Box::new(elif)),
        }
    },
    "if" <cond:Expr> <true_block:Block> "else" <false_block:Block> => {
        Expr::If {
            cond: Box::new(cond),
            true_expr: Box::new(Expr::Block(true_block)),
            false_expr: Some(Box::new(Expr::Block(false_block))),
        }
    },
};

FunctionCall: Expr = {
    <Ident> "(" <Comma<Expr>> ")" => Expr::FnCall(<>),
};

Let: Expr = {
    "let" <id:Ident> <typ:(":" <TypePath>)?> "=" <e:Expr> => {
        Expr::Let(id, Box::new(e))
    },
};

Set: Expr = {
    <id:Ident> "=" <e:Expr> => Expr::Set(id, Box::new(e)),
    <id:Ident> "+=" <e:Expr> => Expr::Set(id.clone(), Box::new(Expr::Binary(BinOp::Add, Box::new(Expr::Ident(id)), Box::new(e)))),
    <id:Ident> "-=" <e:Expr> => Expr::Set(id.clone(), Box::new(Expr::Binary(BinOp::Sub, Box::new(Expr::Ident(id)), Box::new(e)))),
    <id:Ident> "*=" <e:Expr> => Expr::Set(id.clone(), Box::new(Expr::Binary(BinOp::Mul, Box::new(Expr::Ident(id)), Box::new(e)))),
    <id:Ident> "/=" <e:Expr> => Expr::Set(id.clone(), Box::new(Expr::Binary(BinOp::Div, Box::new(Expr::Ident(id)), Box::new(e)))),
};

ExprTier<Op, NextTier>: Expr = {
    <l:ExprTier<Op, NextTier>> <op:Op> <r:NextTier> => {
        Expr::Binary(op, Box::new(l), Box::new(r))
    },
    NextTier,
};

// TODO: Work in "and" and "or" but make it an error for them to be used at the
// same precedance
ExprP0 = ExprTier<OpP0, ExprP1>;
OpP0: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Neq,
};

ExprP1: Expr = {
    <l:ExprP1> <op:OpP1> <r:ExprP2> => {
        Expr::Binary(op, Box::new(l), Box::new(r))
    },
    // Don't let logical operators be on the same level
    <l:ExprP2> <op:LogicalOp> <r:ExprP2> => {
        Expr::Binary(op, Box::new(l), Box::new(r))
    },
    ExprP2,
};
LogicalOp: BinOp = {
    "and" => BinOp::Land,
    "or" => BinOp::Lor,
};
OpP1: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

ExprP2 = ExprTier<OpP2, UnaryExpr>;
OpP2: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

UnaryExpr = {
    "-" <a:Atom> => Expr::Unary(UnaryOp::Neg, Box::new(a)),
    Atom,
}

Atom: Expr = {
    Literal,
    Ident => Expr::Ident(<>),
    "(" <Expr> ")",
};

Ident: Ident = {
    "Ident" => Ident { name: <>.to_string() },
};

TypePath: TypePath = {
    <mut parents:(<Ident> ".")*> <typ:Ident> => {
        parents.push(typ);
        TypePath { path: parents }
    },
};

pub(crate) Literal: Expr = {
    Float => Expr::Literal(<>),
    Int => Expr::Literal(<>),
    Bool => Expr::Literal(<>),
    String => Expr::Literal(<>),
};

// TODO: Trailing types to specify the type of the expression
Int: Literal = {
    "Int" => Literal::parse_int(<>, 10),
    "IntHex" => Literal::parse_int(&<>[2..], 16),
    "IntOct" => Literal::parse_int(&<>[2..], 8),
    "IntBin" => Literal::parse_int(&<>[2..], 2),
}

// TODO: Scientific notation E[+-]NUM stuff
// TODO: Trailing types to specify the type of the expression
Float: Literal = {
    // Has a decimal
    "Float" => Literal::parse_float(<>),
};

Bool: Literal = {
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};

String: Literal = {
    "String" => {
        // The string is currently completely unprocessed
        let s = <>;
        // Unescape quotes
        let s = s[1..s.len()-1].replace("\\\"", "\"");
        Literal::String(s)
    }
};
