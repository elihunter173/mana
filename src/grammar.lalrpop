use bumpalo::{collections::Vec as BumpVec, Bump};

use crate::ast::{UnaryOp, BinOp, Block, Expr, Ident, TypePath, Literal};

// XXX: I have things I test marked as pub(crate)

grammar(bump: &'input Bump);

Delimited<T, Delimiter>: BumpVec<'input, T> = {
    <v:(<T> Delimiter)*> <e:T?> => {
        let mut v = BumpVec::from_iter_in(v, bump);
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

Comma<T> = Delimited<T, ",">;

pub Program = Stmt*;

Stmt = <Expr> ";";

pub(crate) Expr: Expr<'input> = {
    ExprP0,
    Block => Expr::Block(<>),
    If,
    FunctionCall,
    Let,
    Set,
};

Block: Block<'input> = {
    "{" <stmts:Stmt*> "}" => {
        let stmts = stmts.into_iter().map(|x| bump.alloc(x));
        BumpVec::from_iter_in(stmts, bump)
    },
};

If: Expr<'input> = {
    "if" <cond:Expr> <true_block:Block> => {
        Expr::If {
            cond: bump.alloc(cond),
            true_expr: bump.alloc(Expr::Block(true_block)),
            false_expr: None,
        }
    },
    "if" <cond:Expr> <true_block:Block> "else" <elif:If> => {
        Expr::If {
            cond: bump.alloc(cond),
            true_expr: bump.alloc(Expr::Block(true_block)),
            false_expr: Some(bump.alloc(elif)),
        }
    },
    "if" <cond:Expr> <true_block:Block> "else" <false_block:Block> => {
        Expr::If {
            cond: bump.alloc(cond),
            true_expr: bump.alloc(Expr::Block(true_block)),
            false_expr: Some(bump.alloc(Expr::Block(false_block))),
        }
    },
};

FunctionCall: Expr<'input> = {
    <Ident> "(" <Comma<Expr>> ")" => Expr::FnCall(<>),
};

Let: Expr<'input> = {
    "let" <id:Ident> <typ:(":" <TypePath>)?> "=" <e:Expr> => {
        Expr::Let(id, bump.alloc(e))
    },
};

Set: Expr<'input> = {
    <id:Ident> "=" <e:Expr> => Expr::Set(id, bump.alloc(e)),
};

ExprTier<Op, NextTier>: Expr<'input> = {
    <l:ExprTier<Op, NextTier>> <op:Op> <r:NextTier> => {
        Expr::Binary(op, bump.alloc(l), bump.alloc(r))
    },
    NextTier,
};

// TODO: Work in "and" and "or" but make it an error for them to be used at the
// same precedance
ExprP0 = ExprTier<OpP0, ExprP1>;
OpP0: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Neq,
};

ExprP1: Expr<'input> = {
    <l:ExprP1> <op:OpP1> <r:ExprP2> => {
        Expr::Binary(op, bump.alloc(l), bump.alloc(r))
    },
    // Don't let logical operators be on the same level
    <l:ExprP2> <op:LogicalOp> <r:ExprP2> => {
        Expr::Binary(op, bump.alloc(l), bump.alloc(r))
    },
    ExprP2,
};
LogicalOp: BinOp = {
    "and" => BinOp::Land,
    "or" => BinOp::Lor,
};
OpP1: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

ExprP2 = ExprTier<OpP2, UnaryExpr>;
OpP2: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

UnaryExpr = {
    "-" <a:Atom> => Expr::Unary(UnaryOp::Neg, bump.alloc(a)),
    Atom,
}

Atom: Expr<'input> = {
    Literal,
    Ident => Expr::Ident(<>),
    "(" <Expr> ")",
};

Ident: Ident<'input> = {
    r"[a-zA-Z_][0-9a-zA-Z_]*" => Ident { name: <> },
};

TypePath: TypePath<'input> = {
    <parents:(<Ident> ".")*> <typ:Ident> => {
        let mut v = BumpVec::from_iter_in(parents.into_iter(), bump);
        v.push(typ);
        TypePath { paths: v }
    },
};

pub(crate) Literal: Expr<'input> = {
    Float => Expr::Literal(<>),
    Int => Expr::Literal(<>),
    Bool => Expr::Literal(<>),
    String => Expr::Literal(<>),
};

// TODO: Trailing types to specify the type of the expression
Int: Literal = {
    r"[0-9][_0-9]*" => Literal::parse_int(<>, 10),
    r"0x[_0-9a-fA-F]*[0-9a-fA-F][_0-9a-fA-F]*" => Literal::parse_int(&<>[2..], 16),
    r"0o[_0-7]*[0-7][_0-7]*" => Literal::parse_int(&<>[2..], 8),
    r"0b[_01]*[01][_01]*" => Literal::parse_int(&<>[2..], 2),
}

// TODO: Scientific notation E[+-]NUM stuff
// TODO: Trailing types to specify the type of the expression
Float: Literal = {
    // Has a decimal
    r"[0-9][_0-9]*\.[0-9][_0-9]*" => Literal::parse_float(<>),
    // Has a scientific thing
    r"[0-9][_0-9]*(\.[0-9][_0-9]*)?[eE][+-]?[_0-9]*[0-9][_0-9]*" => Literal::parse_float(<>),
    "inf" => Literal::Float(f64::INFINITY),
    "NaN" => Literal::Float(f64::NAN),
};

Bool: Literal = {
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};

String: Literal = {
    <x:r#""([^\\"]|\\")*""#> => {
        let s = &x[1..(x.len() - 1)];
        // Unescape quotes
        let s = s.replace("\\\"", "\"");
        Literal::String(s)
    }
};
