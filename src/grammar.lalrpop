use crate::ast::{UnaryOp, BinOp, Expr, Ident, TypePath, Literal};
use crate::lexer::{LexError, Loc, Tok};

// XXX: I have things I test marked as pub(crate)

grammar<'input>(input: &'input str);

extern {
    type Location = Loc;
    type Error = LexError;

    enum Tok<'input> {
        "," => Tok::Comma,
        ":" => Tok::Colon,
        ";" => Tok::Semicolon,
        "->" => Tok::SingleArrow,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LCurly,
        "}" => Tok::RCurly,
        "[" => Tok::LSquare,
        "]" => Tok::RSquare,

        "=" => Tok::Equals,
        "." => Tok::Dot,
        ".." => Tok::DotDot,
        "..=" => Tok::DotDotEq,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Star,
        "/" => Tok::Slash,

        "fn" => Tok::Fn,
        "let" => Tok::Let,
        "if" => Tok::If,
        "else" => Tok::Else,
        "for" => Tok::For,
        "while" => Tok::While,
        "loop" => Tok::Loop,
        "and" => Tok::And,
        "or" => Tok::Or,
        "not" => Tok::Not,

        "==" => Tok::DoubleEquals,
        "!=" => Tok::BangEquals,
        ">" => Tok::Gt,
        ">=" => Tok::Geq,
        "<" => Tok::Lt,
        "<=" => Tok::Leq,

        "true" => Tok::True,
        "false" => Tok::False,
        "Ident" => Tok::Ident(<&'input str>),
        "String" => Tok::String(<&'input str>),
        "Int" => Tok::Int(<&'input str>),
        "Float" => Tok::Float(<&'input str>),
    }
}


Delimited<T, Delimiter>: Vec<T> = {
    <mut v:(<T> Delimiter)*> <e:T?> => {
        if let Some(e) = e {
            v.push(e);
        }
        v
    }
};

Comma<T> = Delimited<T, ",">;

pub Program = Stmt*;

Stmt = <Expr> ";";

pub(crate) Expr: Expr = {
    ExprP0,
    Block => Expr::Block(<>),
    If,
    FunctionCall,
    Let,
    Set,
};

Block: Vec<Expr> = {
    "{" <stmts:Stmt*> "}" => stmts,
};

If: Expr = {
    "if" <cond:Expr> <true_block:Block> => {
        Expr::If {
            cond: Box::new(cond),
            true_expr: Box::new(Expr::Block(true_block)),
            false_expr: None,
        }
    },
    "if" <cond:Expr> <true_block:Block> "else" <elif:If> => {
        Expr::If {
            cond: Box::new(cond),
            true_expr: Box::new(Expr::Block(true_block)),
            false_expr: Some(Box::new(elif)),
        }
    },
    "if" <cond:Expr> <true_block:Block> "else" <false_block:Block> => {
        Expr::If {
            cond: Box::new(cond),
            true_expr: Box::new(Expr::Block(true_block)),
            false_expr: Some(Box::new(Expr::Block(false_block))),
        }
    },
};

FunctionCall: Expr = {
    <Ident> "(" <Comma<Expr>> ")" => Expr::FnCall(<>),
};

Let: Expr = {
    "let" <id:Ident> <typ:(":" <TypePath>)?> "=" <e:Expr> => {
        Expr::Let(id, Box::new(e))
    },
};

Set: Expr = {
    <id:Ident> "=" <e:Expr> => Expr::Set(id, Box::new(e)),
};

ExprTier<Op, NextTier>: Expr = {
    <l:ExprTier<Op, NextTier>> <op:Op> <r:NextTier> => {
        Expr::Binary(op, Box::new(l), Box::new(r))
    },
    NextTier,
};

// TODO: Work in "and" and "or" but make it an error for them to be used at the
// same precedance
ExprP0 = ExprTier<OpP0, ExprP1>;
OpP0: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Neq,
};

ExprP1: Expr = {
    <l:ExprP1> <op:OpP1> <r:ExprP2> => {
        Expr::Binary(op, Box::new(l), Box::new(r))
    },
    // Don't let logical operators be on the same level
    <l:ExprP2> <op:LogicalOp> <r:ExprP2> => {
        Expr::Binary(op, Box::new(l), Box::new(r))
    },
    ExprP2,
};
LogicalOp: BinOp = {
    "and" => BinOp::Land,
    "or" => BinOp::Lor,
};
OpP1: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

ExprP2 = ExprTier<OpP2, UnaryExpr>;
OpP2: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
};

UnaryExpr = {
    "-" <a:Atom> => Expr::Unary(UnaryOp::Neg, Box::new(a)),
    Atom,
}

Atom: Expr = {
    Literal,
    Ident => Expr::Ident(<>),
    "(" <Expr> ")",
};

Ident: Ident = {
    "Ident" => Ident { name: <>.to_string() },
};

TypePath: TypePath = {
    <mut parents:(<Ident> ".")*> <typ:Ident> => {
        parents.push(typ);
        TypePath { paths: parents }
    },
};

pub(crate) Literal: Expr = {
    Float => Expr::Literal(<>),
    Int => Expr::Literal(<>),
    Bool => Expr::Literal(<>),
    String => Expr::Literal(<>),
};

// TODO: Trailing types to specify the type of the expression
Int: Literal = {
    "Int" => {
        let s = <>;
        if s.starts_with("0x") {
            Literal::parse_int(&s[2..], 16)
        } else if s.starts_with("0o") {
            Literal::parse_int(&s[2..], 8)
        } else if s.starts_with("0b") {
            Literal::parse_int(&s[2..], 2)
        } else {
            Literal::parse_int(<>, 10)
        }
    }
}

// TODO: Scientific notation E[+-]NUM stuff
// TODO: Trailing types to specify the type of the expression
Float: Literal = {
    // Has a decimal
    "Float" => Literal::parse_float(<>),
};

Bool: Literal = {
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};

String: Literal = {
    "String" => Literal::String(<>.to_owned()),
};
